/* ... Error */
#if __CPP__VERSION__ < 2011uL
#   error [LAPYS]: Lacking support for C++ versions before the ISO C++11 standard; Features required include: [*] Lookup deference via `using` declaration, [*] Trailing function return type, [*] Variadic template parameter
#endif

/* ... > Utility --- NOTE (Lapys) */
namespace Lapys {
    /* ... Definition > ... */
    inline namespace Utility {
        // ...
        namespace { // -> Miscellaneous...
            enum any_t {};
            enum null_t {};

            #if __CPP__VERSION__ < 2011uL
                template <typename>
                struct to_null_t final { public: typedef null_t type; }; // -> doesn't defer to `alias<...>`
            #else
                template <typename...>
                struct to_null_t final { public: typedef null_t type; }; // -> doesn't defer to `alias<...>`
            #endif
        }

        // ...
        template <typename, std::size_t = 0u> struct add_bound;
        template <typename> struct add_const;
        template <typename> struct add_cv;
        template <typename> struct add_lvalue_reference;
        template <typename, typename = null_t> struct add_pointer;
        template <typename> struct add_qualifiers;
        template <typename> struct add_reference;
        template <typename> struct add_rvalue_reference;
        template <typename> struct add_volatile;
        template <typename> struct alias;
        template <typename, typename = null_t> struct baseof;
        template <bool> struct boolean;
        template <bool, typename, typename = null_t> struct conditional_alias;
        template <typename> struct decayof;
        template <typename> struct depthof;
        template <typename type, type> struct integer;
        template <typename> struct is_abstract;
        template <typename> struct is_array;
        template <typename> struct is_array_pointer;
        template <typename> struct is_array_reference;
        template <class, typename = null_t> struct is_base;
        template <typename> struct is_bounded_array;
        template <typename> struct is_character;
        template <class, typename = null_t> struct is_class;
        template <typename> struct is_const;
        template <typename> struct is_enum;
        template <typename> struct is_final;
        template <typename> struct is_floating_point;
        template <typename> struct is_function;
        template <typename> struct is_function_pointer;
        template <typename> struct is_function_reference;
        template <typename> struct is_integer;
        template <typename> struct is_member_pointer;
        template <typename> struct is_member_function_pointer;
        template <typename> struct is_member_object_pointer;
        template <typename> struct is_noexcept;
        template <typename> struct is_number;
        template <typename> struct is_object;
        template <typename> struct is_object_pointer;
        template <typename> struct is_object_reference;
        template <typename> struct is_pointer;
        template <typename> struct is_reference;
        template <typename, typename> struct is_same;
        template <typename> struct is_scoped_enum;
        template <typename> struct is_signed;
        template <typename> struct is_unbounded_array;
        template <class> struct is_union;
        template <typename> struct is_unscoped_enum;
        template <typename> struct is_unsigned;
        template <typename> struct is_variadic;
        template <typename> struct is_void;
        template <typename> struct is_volatile;
        template <typename> struct lengthof;
        template <bool, typename, typename> struct method;
        template <typename, typename> struct method_accessor;
        template <typename, typename> struct method_mutator;
        template <class, typename> struct property;
        template <class, typename> struct property_accessor;
        template <class, typename> struct property_mutator;
        template <typename> struct remove_bound;
        template <typename> struct remove_bounds;
        template <typename> struct remove_const;
        template <typename> struct remove_cv;
        template <typename> struct remove_lvalue_reference;
        template <typename> struct remove_pointer;
        template <typename> struct remove_qualifiers;
        template <typename> struct remove_reference;
        template <typename> struct remove_rvalue_reference;
        template <typename> struct remove_specifications;
        template <typename> struct remove_volatile;
        template <typename> struct shadow;
        template <typename> struct to_signed;
        template <typename> struct to_unsigned;

        // ...
        template <typename type> constexpr typename decayof<type>::type decay(type nodecay);
        template <typename return_t, typename cast_t> return_t direct_cast(cast_t nodecay);
        #if __CPP__VERSION__ < 2011uL
            template <typename type> constexpr inline typename remove_const<typename remove_reference<type>::type>::type& forward(typename remove_const<typename remove_reference<type>::type>::type& argument) except(false);
            template <typename type> constexpr inline typename remove_const<typename remove_reference<type>::type>::type const& forward(typename remove_const<typename remove_reference<type>::type>::type const& argument) except(false);
        #else
            template <typename type> constexpr inline type&& forward(typename remove_reference<type>::type&) except(false);
            template <typename type> constexpr inline type&& forward(typename remove_reference<type>::type&&) except(false);
        #endif
        template <typename type> constexpr inline typename conditional_alias<is_void<type>::value, void, type&&>::type instanceof(void) except(false);
    }

    /* ... Class */
    inline namespace Utility {
        // Alias, Boolean -> Base constructs for consistent behavior to other "derived" constructs.
        template <typename alias_t> struct alias { public: typedef alias_t type; };
        template <bool state> struct boolean : public integer<bool, state> {};
        template <typename type, type constant> struct integer { public: constexpr static type const value = constant; };

        /* Conditional Alias -> Evaluates to either type specified based on a boolean condition.
                If an alternate type isn't specified, no `type` will be evaluated.
        */
        template <bool, typename, typename> struct conditional_alias {};
        template <typename type> struct conditional_alias<false, type> {};
        template <typename true_t, typename false_t> struct conditional_alias<false, true_t, false_t> : public alias<false_t> {};
        template <typename true_t, typename false_t> struct conditional_alias<true, true_t, false_t> : public alias<true_t> {};
    }

    inline namespace Utility {
        // Add Bound
        template <typename base, std::size_t length>
        struct add_bound : public alias<base [length]> {};

        template <typename base>
        struct add_bound<base> : public alias<base []> {};

        // Add (Constant, Volatile)
        template <typename type> struct add_const : public alias<type const> {};
        template <typename type> struct add_volatile : public alias<type volatile> {};

        template <typename type>
        struct add_cv : public alias<typename add_const<typename add_volatile<type>::type>::type> {};

        // Add Pointer
        template <typename base, class object> struct add_pointer : public alias<base object::*> {};
        template <typename type> struct add_pointer<type> : public alias<type*> {};

        // Add Qualifiers
        template <typename type>
        struct add_qualifiers : public alias<typename add_cv<typename add_reference<type>::type>::type> {};

        // Add ... Reference
        template <typename type> struct add_lvalue_reference : public alias<type&> {};
        #if __CPP__VERSION__ >= 2011uL
            template <typename type> struct add_rvalue_reference : public alias<type&&> {};
        #endif

        template <typename type>
        struct add_reference : public alias<typename add_lvalue_reference<typename add_rvalue_reference<type>::type>::type> {};

        /* Base Of -> Denotes the underlying type of the specified `typename`.
                For base types, unless a fallback `subtype` is specified, no `type` will be evaluated.
        */
        namespace {
            // ...
            template <typename type>
            struct baseof_enum_t : public alias<
                # if __COMPILER_IS__ARM__
                #   ifdef __underlying_type
                        __underlying_type(type)
                #   else
                        typename conditional_alias<(static_cast<type>(-1) < static_cast<type>(0)), typename to_signed<type>::type, typename to_unsigned<type>::type>::type
                #   endif
                # elif __COMPILER_IS__CLANG__
                        __underlying_type(type)
                # else
                        typename conditional_alias<
                            (static_cast<type>(-1) < static_cast<type>(0)),
                            typename to_signed<type>::type, typename to_unsigned<type>::type
                        >::type
                # endif
            > {};
            template <> struct baseof_enum_t<bool> : public alias<bool> {};
            template <> struct baseof_enum_t<char> : public alias<char> {};
            template <> struct baseof_enum_t<char8_t> : public alias<char8_t> {};
            template <> struct baseof_enum_t<char16_t> : public alias<char16_t> {};
            template <> struct baseof_enum_t<char32_t> : public alias<char32_t> {};
            template <> struct baseof_enum_t<wchar_t> : public alias<wchar_t> {};

            // ...
            template <bool, typename type> struct baseof_t;
            template <typename type> struct baseof_t<false, type> : public alias<type> {};
            template <typename base> struct baseof_t<false, base []> : public alias<base> {};
            template <typename base, std::size_t length> struct baseof_t<false, base [length]> : public alias<base> {};
            template <typename base, typename... types> struct baseof_t<false, base (types...)> : public alias<base> {};
            template <typename base, typename... types> struct baseof_t<false, base (types..., ...)> : public alias<base> {};
            template <typename type> struct baseof_t<true, type> : public alias<typename baseof_enum_t<type>::type> {};
        }

        template <typename type, typename subtype>
        struct baseof : public baseof_t<
            is_enum<type>::value,
            typename conditional_alias<
                (is_array<type>::value || is_array_pointer<type>::value || is_array_reference<type>::value) ||
                (is_function<type>::value || is_function_pointer<type>::value || is_function_reference<type>::value),

                typename remove_pointer<typename remove_qualifiers<typename remove_specifications<type>::type>::type>::type,
                subtype
            >::type
        > {};

        // Decay Of
        namespace {
            template <typename type>
            struct decayof_t : public alias<
                typename conditional_alias<
                    is_array<type>::value,
                    typename remove_bound<type>::type*,
                typename conditional_alias<
                    is_function<type>::value,
                    typename add_pointer<type>::type,
                typename remove_cv<type>::type >::type >::type
            > {
            };
        }

        template <typename type>
        struct decayof : public decayof_t<typename remove_reference<type>::type> {};

        // Depth Of
        template <typename> struct depthof : public integer<std::size_t, 0u> {};
        template <typename base> struct depthof<base []> : public integer<std::size_t, depthof<base>::value + 1u> {};
        template <typename base, std::size_t length> struct depthof<base [length]> : public integer<std::size_t, depthof<base>::value + 1u> {};

        // Is Abstract
        template <typename type>
        struct is_abstract : public boolean<
            #if __CPP__VERSION__ < 2011uL
            #   if __COMPILER_IS__ARM__
            #     ifdef __is_abstract
                    __is_abstract(type)
            #     else
                    false
            #     endif
            #   elif __COMPILER_IS__GNU__ || __COMPILER_IS__MSVC__
                    __is_abstract(type)
            #   else
                    false
            #   endif
            #else
                std::is_abstract<type>::value
            #endif
        > {};

        // Is Array ...
        template <typename> struct is_array : public boolean<false> {};
        template <typename base> struct is_array<base []> : public boolean<true> {};
        template <typename base, std::size_t length> struct is_array<base [length]> : public boolean<true> {};

        template <typename type> struct is_array_pointer : public boolean<is_array<typename remove_pointer<type>::type>::value && false == is_array<type>::value> {};
        template <typename type> struct is_array_reference : public boolean<is_array<typename remove_reference<type>::type>::value && false == is_array<type>::value> {};

        // Is Base ...
        namespace {
            // ...
            template <typename type> constexpr inline static bool const (&disambiguate_assert(type const volatile* const) except(false))[true + 1];
            template <typename> constexpr inline static bool const (&disambiguate_assert(void const volatile* const) except(false))[false + 1];

            template <typename base, typename derived> constexpr inline static bool const (&disambiguate(int const) except(false))[sizeof(disambiguate_assert<base>(static_cast<derived*>(NULL)))];
            template <typename, typename> constexpr inline static bool const (&disambiguate(...) except(false))[true + 1];

            // ...
            template <typename type>
            struct is_base_t : public boolean<
                (is_array<type>::value || is_array_reference<type>::value) || (
                    is_character<type>::value ||
                    is_function<type>::value ||
                    is_number<type>::value ||
                    is_pointer<type>::value
                )
            > {};
            template <> struct is_base_t<bool> : public boolean<true> {};
            template <> struct is_base_t<void> : public boolean<true> {};

            // ...
            template <class base, class derived>
            struct is_baseof_t : public boolean<
                (is_class<base>::value && is_class<derived>::value) ?
                    sizeof(bool[true + 1]) == sizeof(disambiguate<base, derived>(0)) :
                    is_same<base, derived>::value
            > {};

            template <class type> struct is_baseof_t<type, type> : public boolean<false> {};
        }

        template <class base, class derived>
        struct is_base : public is_baseof_t<base, derived> {};

        template <typename type>
        struct is_base<type> : public is_base_t<
            typename conditional_alias<
                is_array<type>::value || is_array_reference<type>::value,
                typename baseof<type, type /* -> Enforce `baseof` to always evaluate a type (although it may never actually be computed). */>::type,
                typename remove_reference<type>::type
            >::type
        > {};

        // Is (Un)Bounded Array
        template <typename> struct is_bounded_array : public boolean<false> {};
        template <typename base, std::size_t length> struct is_bounded_array<base [length]> : public boolean<true> {};

        template <typename> struct is_unbounded_array : public boolean<false> {};
        template <typename base> struct is_unbounded_array<base []> : public boolean<true> {};

        // Is Character
        template <typename> struct is_character : public boolean<false> {};
        template <> struct is_character<char> : public boolean<true> {};
        template <> struct is_character<char8_t> : public boolean<true> {};
        template <> struct is_character<char16_t> : public boolean<true> {};
        template <> struct is_character<char32_t> : public boolean<true> {};
        template <> struct is_character<wchar_t> : public boolean<true> {};

        // Is Class
        template <class, typename> struct is_class : public boolean<false> {};
        template <class type> struct is_class<type, typename to_null_t<any_t type::*>::type> : public boolean<false == is_union<type>::value> {};

        // Is Constant
        template <typename> struct is_const : public boolean<false> {};
        template <typename type> struct is_const<type const> : public boolean<true> {};

        // Is Final
        template <class type>
        struct is_final : public boolean<
            #if __CPP__VERSION__ < 2014uL
            #   if __COMPILER_IS__CLANG__
                    __is_final(type)
            #   elif __COMPILER_IS__GNU__
            #     if defined(__has_builtin) && __has_builtin(__is_final)
                    __is_final(type)
            #     else
                    false
            #     endif
            #   elif __COMPILER_IS__MSVC__
                    __is_sealed(type)
            #   else
                    false
            #   endif
            #else
                std::is_final<type>::value
            #endif
        > {};

        // Is (Floating-Point, Integer, ...)
        template <typename> struct is_floating_point : public boolean<false> {};
        template <> struct is_floating_point<double> : public boolean<true> {};
        template <> struct is_floating_point<float> : public boolean<true> {};
        template <> struct is_floating_point<long double> : public boolean<true> {};

        template <typename> struct is_integer : public boolean<false> {};
        template <> struct is_integer<signed char> : public boolean<true> {};
        template <> struct is_integer<signed int> : public boolean<true> {};
        template <> struct is_integer<signed long> : public boolean<true> {};
        template <> struct is_integer<signed short> : public boolean<true> {};
        template <> struct is_integer<unsigned char> : public boolean<true> {};
        template <> struct is_integer<unsigned int> : public boolean<true> {};
        template <> struct is_integer<unsigned long> : public boolean<true> {};
        template <> struct is_integer<unsigned short> : public boolean<true> {};
        #if __CPP__VERSION__ >= 2011uL
            template <> struct is_integer<signed long long> : public boolean<true> {};
            template <> struct is_integer<unsigned long long> : public boolean<true> {};
        #endif

        template <typename type>
        struct is_number : public boolean<is_floating_point<type>::value || is_integer<type>::value> {};

        // Is Function ...
        namespace {
            template <typename> struct is_function_t : public boolean<false> {};
            template <typename base, typename... types> struct is_function_t<base (types...)> : public boolean<true> {};
            template <typename base, typename... types> struct is_function_t<base (types..., ...)> : public boolean<true> {};
        }

        template <typename type> struct is_function : public is_function_t<typename remove_specifications<type>::type> {};
        template <typename type> struct is_function_pointer : public boolean<is_member_function_pointer<type>::value || (is_function<typename remove_pointer<type>::type>::value && false == is_function<type>::value)> {};
        template <typename type> struct is_function_reference : public boolean<is_function<typename remove_reference<type>::type>::value && false == is_function<type>::value> {};

        // Is Member ...
        template <typename> struct is_member_pointer : public boolean<false> {};
        template <typename base, typename object> struct is_member_pointer<base object::*> : public boolean<true> {};
        // template <typename type> struct is_member_pointer<type*> : public boolean<is_member_pointer<type>::value> {};
        // template <typename type> struct is_member_pointer<type const*> : public boolean<is_member_pointer<type>::value> {};
        // template <typename type> struct is_member_pointer<type const volatile*> : public boolean<is_member_pointer<type>::value> {};
        // template <typename type> struct is_member_pointer<type volatile*> : public boolean<is_member_pointer<type>::value> {};
        template <typename base, typename object> struct is_member_pointer<base object::* const> : public boolean<is_member_pointer<base object::*>::value> {};
        template <typename base, typename object> struct is_member_pointer<base object::* const volatile> : public boolean<is_member_pointer<base object::*>::value> {};
        template <typename base, typename object> struct is_member_pointer<base object::* volatile> : public boolean<is_member_pointer<base object::*>::value> {};

        template <typename> struct is_member_function_pointer : public boolean<false> {};
        template <typename base, typename object> struct is_member_function_pointer<base object::*> : public boolean<is_function<base>::value> {};
        // template <typename type> struct is_member_function_pointer<type*> : public boolean<is_member_function_pointer<type>::value> {};
        // template <typename type> struct is_member_function_pointer<type const*> : public boolean<is_member_function_pointer<type>::value> {};
        // template <typename type> struct is_member_function_pointer<type const volatile*> : public boolean<is_member_function_pointer<type>::value> {};
        // template <typename type> struct is_member_function_pointer<type volatile*> : public boolean<is_member_function_pointer<type>::value> {};
        template <typename base, typename object> struct is_member_function_pointer<base object::* const> : public boolean<is_member_function_pointer<base object::*>::value> {};
        template <typename base, typename object> struct is_member_function_pointer<base object::* const volatile> : public boolean<is_member_function_pointer<base object::*>::value> {};
        template <typename base, typename object> struct is_member_function_pointer<base object::* volatile> : public boolean<is_member_function_pointer<base object::*>::value> {};

        template <typename type>
        struct is_member_object_pointer : public boolean<is_member_pointer<type>::value && false == is_member_function_pointer<type>::value> {};

        // Is Non-Exception
        namespace {
            template <typename type> struct is_noexcept_t : public boolean<false> {};
            template <typename base, typename... types> struct is_noexcept_t<base (types...) except(false)> : public boolean<true> {};
            template <typename base, typename object, typename... types> struct is_noexcept_t<base (object::*)(types...) except(false)> : public boolean<true> {};
        }

        template <typename type>
        struct is_noexcept : public is_noexcept_t<typename remove_specifications<type>::type> {};

        // Is Object ...
        template <typename>
        struct is_object : public boolean<true> {};

        template <typename> struct is_object_pointer : public boolean<false> {};
        template <typename type> struct is_object_pointer<type*> : public boolean<true> {};
        template <typename type> struct is_object_pointer<type* const> : public boolean<true> {};
        template <typename type> struct is_object_pointer<type* const volatile> : public boolean<true> {};
        template <typename type> struct is_object_pointer<type* volatile> : public boolean<true> {};

        template <typename> struct is_object_reference : public boolean<false> {};
        template <typename type> struct is_object_reference<type&> : public boolean<true> {};
        #if __CPP__VERSION__ >= 2011uL
            template <typename type> struct is_object_reference<type&&> : public boolean<true> {};
        #endif

        // Is (Pointer, Reference)
        template <typename type> struct is_pointer : public boolean<is_array_pointer<type>::value || is_function_pointer<type>::value || is_object_pointer<type>::value> {};
        template <typename type> struct is_reference : public boolean<is_array_reference<type>::value || is_function_reference<type>::value || is_object_reference<type>::value> {};

        // Is Same
        template <typename, typename> struct is_same : public boolean<false> {};
        template <typename type> struct is_same<type, type> : public boolean<true> {};

        // Is (Un)Signed
        template <typename> struct is_signed : public boolean<false> {};
        template <> struct is_signed<signed char> : public boolean<true> {};
        template <> struct is_signed<signed int> : public boolean<true> {};
        template <> struct is_signed<signed long> : public boolean<true> {};
        template <> struct is_signed<signed short> : public boolean<true> {};

        template <typename> struct is_unsigned : public boolean<false> {};
        template <> struct is_unsigned<unsigned char> : public boolean<true> {};
        template <> struct is_unsigned<unsigned int> : public boolean<true> {};
        template <> struct is_unsigned<unsigned long> : public boolean<true> {};
        template <> struct is_unsigned<unsigned short> : public boolean<true> {};

        #if __CPP__VERSION__ >= 2011uL
            template <> struct is_signed<signed long long> : public boolean<true> {};
            template <> struct is_unsigned<unsigned long long> : public boolean<true> {};
        #endif

        // Is Union
        template <class type>
        struct is_union : public boolean<
            #if __CPP__VERSION__ < 2011uL
            #   if __COMPILER_IS__ARM__
            #     ifdef __is_union
                    __is_union(type)
            #     else
                    false
            #     endif
            #   elif __COMPILER_IS__GNU__ || __COMPILER_IS__MSVC__
                    __is_union(type)
            #   else
                    false
            #   endif
            #else
                std::is_union<type>::value
            #endif
        > {};

        // Is Variadic
        namespace {
            template <typename> struct is_variadic_t : public boolean<false> {};
            template <typename base, typename... types> struct is_variadic_t<base (types..., ...)> : public boolean<true> {};
        }

        template <typename type>
        struct is_variadic : public is_variadic_t<typename remove_pointer<typename remove_qualifiers<typename remove_specifications<type>::type>::type>::type> {};

        // Is ... Enumeration
        namespace {
            template <typename type>
            struct is_unscoped_enum_t {
                constexpr inline static bool const (&disambiguate(int const) except(false))[true + 1];
                constexpr inline static bool const (&disambiguate(...) except(false))[false + 1];

                // -> doesn't defer to `boolean<...>`
                constexpr static bool const value = false == (
                    is_array<type>::value ||
                    is_function<type>::value ||
                    is_number<type>::value ||
                    is_pointer<type>::value ||
                    is_reference<type>::value
                ) && sizeof(bool[true + 1]) == sizeof(disambiguate(instanceof<type>()));
            };
        }

        template <typename type>
        struct is_enum : public boolean<
            #if __CPP__VERSION__ < 2011uL
            #   if __COMPILER_IS__ARM__
            #     ifdef __is_enum
                    __is_enum(type)
            #     else
                    false
            #     endif
            #   elif __COMPILER_IS__GNU__ || __COMPILER_IS__MSVC__
                    __is_enum(type)
            #   else
                    false
            #   endif
            #else
                std::is_enum<type>::value
            #endif
        > {};

        template <typename type>
        struct is_scoped_enum : public boolean<is_enum<type>::value && false == is_unscoped_enum<type>::value> {};

        template <typename type>
        struct is_unscoped_enum : public is_unscoped_enum_t<type> {};

        // Is Void
        template <typename> struct is_void : public boolean<false> {};
        template <> struct is_void<void> : public boolean<true> {};

        // Is Volatile
        template <typename> struct is_volatile : public boolean<false> {};
        template <typename type> struct is_volatile<type volatile> : public boolean<true> {};

        // Length Of
        template <typename> struct lengthof : public integer<std::size_t, 0u> {};
        template <typename base> struct lengthof<base []> : public integer<std::size_t, 0u> {};
        template <typename base, std::size_t length> struct lengthof<base [length]> : public integer<std::size_t, length> {};

        // Property
        template <class object, typename alias_t>
        struct property : public shadow<alias_t> {
            friend object;

            public:
                constexpr inline property(property const& property) except(false) : shadow<alias_t> super(static_cast<shadow<alias_t> const&>(property)) {}
                template <typename... types> constexpr inline property(types nodecay... arguments) except(false) : shadow<alias_t> super(Utility::forward<types>(arguments)...) {}
                #if __CPP__VERSION__ >= 2011uL
                    constexpr inline property(property&& property) except(false) : shadow<alias_t> super(static_cast<shadow<alias_t>&&>(property)) {}
                #endif

                constexpr inline auto operator =(property const& property) except(false) -> typeof(static_cast<shadow<alias_t>&>(const_cast<Utility::property<object, alias_t>&>(*this)) = static_cast<shadow<alias_t> const&>(property)) { return static_cast<shadow<alias_t>&>(const_cast<Utility::property<object, alias_t>&>(*this)) = static_cast<shadow<alias_t> const&>(property); }
                #if __CPP__VERSION__ >= 2011uL
                    constexpr inline auto operator =(property&& property) except(false) -> typeof(static_cast<shadow<alias_t>&>(const_cast<Utility::property<object, alias_t>&>(*this)) = static_cast<shadow<alias_t>&&>(property)) { return static_cast<shadow<alias_t>&>(const_cast<Utility::property<object, alias_t>&>(*this)) = static_cast<shadow<alias_t>&&>(property); }
                #endif
        };

        template <class object, typename alias_t>
        struct property_accessor : public property<object, alias_t> {
            friend object;

            protected:
                constexpr inline property_accessor& operator =(property_accessor const& accessor) except(false) { return this -> property<object, alias_t>::operator =(static_cast<property<object, alias_t> const&>(accessor)); }
                #if __CPP__VERSION__ >= 2011uL
                    constexpr inline property_accessor& operator =(property_accessor&& accessor) except(false) { return this -> property<object, alias_t>::operator =(static_cast<property<object, alias_t>&&>(accessor)); }
                #endif

                template <typename type = alias_t>
                constable inline auto operator +(void) except(false) -> typeof(
                    instanceof<typename remove_reference<typeof((instanceof<property<object, type>>().valueOf()))>::type>()
                    .operator +()
                ) { return static_cast<property<object, type>*>(this) -> operator +(); }

            public:
                constexpr inline property_accessor(property_accessor const& accessor) except(false) : property<object, alias_t> super(static_cast<property<object, alias_t> const&>(accessor)) {}
                template <typename... types> constexpr inline property_accessor(types nodecay... arguments) except(false) : property<object, alias_t> super(Utility::forward<types>(arguments)...) {}
                #if __CPP__VERSION__ >= 2011uL
                    constexpr inline property_accessor(property_accessor&& accessor) except(false) : property<object, alias_t> super(static_cast<property<object, alias_t>&&>(accessor)) {}
                #endif

                template <typename type = alias_t>
                constexpr inline auto operator +(void) const except(false) -> typeof(
                    instanceof<typename add_const<typename remove_reference<typeof((instanceof<property<object, type> const*>().valueOf()))>::type>::type>()
                    .operator +()
                ) { return static_cast<property<object, type> const*>(this) -> operator +(); }
        };

        // template <typename, typename> struct property_mutator;

        // Remove Bound
        template <typename type> struct remove_bound : public alias<type> {};
        template <typename base> struct remove_bound<base []> : public alias<base> {};
        template <typename base, std::size_t length> struct remove_bound<base [length]> : public alias<base> {};

        template <typename type> // -> doesn't defer to `alias<...>`
        struct remove_bounds : public alias<type> {};

        template <typename base> struct remove_bounds<base []> { typedef typename remove_bounds<base>::type type; };
        template <typename base, std::size_t length> struct remove_bounds<base [length]> { typedef typename remove_bounds<base>::type type; };

        // Remove (Constant, Volatile)
        template <typename type> struct remove_const : public alias<type> {};
        template <typename type> struct remove_const<type const> : public alias<type> {};

        template <typename type> struct remove_volatile : public alias<type> {};
        template <typename type> struct remove_volatile<type volatile> : public alias<type> {};

        template <typename type>
        struct remove_cv : public alias<typename remove_const<typename remove_volatile<type>::type>::type> {};

        // Remove Pointer
        template <typename type> struct remove_pointer : public alias<type> {};
        template <typename type> struct remove_pointer<type*> : public alias<type> {};
        template <typename type> struct remove_pointer<type* const> : public alias<type> {};
        template <typename type> struct remove_pointer<type* const volatile> : public alias<type> {};
        template <typename type> struct remove_pointer<type* volatile> : public alias<type> {};
        template <typename base, class object> struct remove_pointer<base object::*> : public alias<base> {};
        template <typename base, class object> struct remove_pointer<base object::* const> : public alias<base> {};
        template <typename base, class object> struct remove_pointer<base object::* const volatile> : public alias<base> {};
        template <typename base, class object> struct remove_pointer<base object::* volatile> : public alias<base> {};

        // Remove Qualifiers
        template <typename type>
        struct remove_qualifiers : public alias<typename remove_cv<typename remove_reference<type>::type>::type> {};

        // Remove Specifications
        template <typename type> struct remove_specifications : public alias<type> {};
        template <typename base, typename... types> struct remove_specifications<base (types...)&> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) const> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) const&> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) const volatile> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) const volatile&> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) volatile> : public alias<base (types...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types...) volatile&> : public alias<base (types...)> {};

        template <typename base, typename... types> struct remove_specifications<base (types..., ...)&> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) const> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) const&> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile&> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile> : public alias<base (types..., ...)> {};
        template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile&> : public alias<base (types..., ...)> {};
        template <typename base, typename object> struct remove_specifications<base object::*> : public alias<base object::*> {};
        template <typename base, typename object> struct remove_specifications<base object::* const> : public alias<base object::*> {};
        template <typename base, typename object> struct remove_specifications<base object::* const volatile> : public alias<base object::*> {};
        template <typename base, typename object> struct remove_specifications<base object::* volatile> : public alias<base object::*> {};
        #if __CPP__VERSION__ >= 2011uL
            template <typename base, typename... types> struct remove_specifications<base (types...)&&> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const&&> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const volatile&&> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) volatile&&> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...)&&> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const&&> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile&&> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile&&> : public alias<base (types..., ...)> {};
        #endif
        #if __CPP__VERSION__ >= 2017uL
            template <typename base, typename... types> struct remove_specifications<base (types...)& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...)&& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const&& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const volatile noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const volatile& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) const volatile&& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) volatile noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) volatile& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types...) volatile&& noexcept> : public alias<base (types...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...)& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...)&& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const&& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) const volatile&& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile& noexcept> : public alias<base (types..., ...)> {};
            template <typename base, typename... types> struct remove_specifications<base (types..., ...) volatile&& noexcept> : public alias<base (types..., ...)> {};
        #endif

        // Remove ... Reference
        template <typename type> struct remove_lvalue_reference : public alias<type> {};
        template <typename type> struct remove_lvalue_reference<type&> : public alias<type> {};

        template <typename type> struct remove_rvalue_reference : public alias<type> {};
        #if __CPP__VERSION__ >= 2011uL
            template <typename type> struct remove_rvalue_reference<type&&> : public alias<type> {};
        #endif

        template <typename type>
        struct remove_reference : public alias<typename remove_lvalue_reference<typename remove_rvalue_reference<type>::type>::type> {};

        // Shadow
        namespace {
            // [Miscellany & State] ...
            enum shadow_layout_t {
                deferred, // -> Non-derivable types.
                derived, // -> Derivable types.
                function_reference, // -> Function reference types.
                undefined // -> ...
            };

            namespace shadow_overlay_t {
                enum address {};
                enum complement {};
                enum dereference {};
                enum negate {};
                enum post_decrement {};
                enum post_increment {};
                enum pre_decrement {};
                enum pre_increment {};
                enum unary_add {};
                enum unary_subtract {};
            }

            // ...
            template <bool, typename> struct shadow_deference final {};
            template <shadow_layout_t, typename> struct shadow_layout final {};
            template <bool, typename> struct shadow_overlay final {};

            // [Assertion] ... -> Differentiate between `shadow` & other types in ambiguous compile-time assertions.
            template <shadow_layout_t layout, typename type, typename conditional_alias<false == is_base<shadow_layout<layout, type>, typename remove_pointer<typename remove_reference<type>::type>::type>::value, bool>::type = 0x0> constexpr inline static type nodecay disambiguate(type nodecay argument) except(false) { return static_cast<type nodecay>(argument); }
            template <shadow_layout_t layout, typename type, typename conditional_alias<true == is_base<shadow_layout<layout, type>, typename remove_pointer<typename remove_reference<type>::type>::type>::value, bool>::type = 0x0> constexpr inline static auto disambiguate(type nodecay argument) except(false) -> typeof(argument.valueOf()) { return argument.valueOf(); }

            template <class, class, typename = null_t> struct has_operator final : public boolean<false> {};
            template <class object> struct has_operator<shadow_overlay_t::address, object, typename to_null_t<typeof(instanceof<object>().operator &())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::complement, object, typename to_null_t<typeof(instanceof<object>().operator ~())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::dereference, object, typename to_null_t<typeof(instanceof<object>().operator *())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::negate, object, typename to_null_t<typeof(instanceof<object>().operator !())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::post_decrement, object, typename to_null_t<typeof(instanceof<object>().operator --(0x0))>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::post_increment, object, typename to_null_t<typeof(instanceof<object>().operator ++(0x0))>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::pre_decrement, object, typename to_null_t<typeof(instanceof<object>().operator --())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::pre_increment, object, typename to_null_t<typeof(instanceof<object>().operator ++())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::unary_add, object, typename to_null_t<typeof(instanceof<object>().operator +())>::type> final : public boolean<true> {};
            template <class object> struct has_operator<shadow_overlay_t::unary_subtract, object, typename to_null_t<typeof(instanceof<object>().operator -())>::type> final : public boolean<true> {};

            // [Layout] ... -> Configure the memory layout of `shadow` to be seamless with the specified `alias_t`.
            template <typename alias_t> // -> For non-derivable types: PODs, `final` `class`es & `struct`s, `union`s, ...
            struct shadow_layout<shadow_layout_t::deferred, alias_t> {
                protected: alias_t value;
                public:
                    template <typename... types> constexpr inline shadow_layout(types nodecay... arguments) except(false) : value super(Utility::forward<types>(arguments)...) {}
                    constexpr inline alias_t& valueOf(void) const except(false) { return const_cast<alias_t&>(this -> value); }
            };

            template <class alias_t> // -> For derivable `class` or `struct` objects.
            struct shadow_layout<shadow_layout_t::derived, alias_t> : public alias_t {
                public:
                    constexpr inline shadow_layout(alias_t const& object) except(false) : alias_t(Utility::forward<alias_t const&>(object)) {}
                    template <typename... types> constexpr inline shadow_layout(types nodecay... arguments) except(false) : alias_t(Utility::forward<types>(arguments)...) {}
                    #if __CPP__VERSION__ >= 2011uL
                        constexpr inline shadow_layout(alias_t&& object) except(false) : alias_t(Utility::forward<alias_t&&>(object)) {}
                    #endif

                    constexpr inline alias_t& valueOf(void) const except(false) { return *const_cast<alias_t*>(static_cast<alias_t const*>(this)); }
            };

            template <typename alias_t> // -> For function reference types.
            struct shadow_layout<shadow_layout_t::function_reference, alias_t> {
                protected: alias_t value;
                public:
                    constexpr inline shadow_layout(typename add_pointer<typename remove_reference<alias_t>::type>::type argument) except(false) : value(*argument) {}
                    constexpr inline alias_t valueOf(void) const except(false) { return this -> value; }
            };
                // ...
                template <typename alias_t>
                struct shadow_layout_alias final { public:
                    typedef shadow_layout<
                        // ...
                        // -> Functions can't be instantiated as variables.
                        is_function<alias_t>::value ?
                            shadow_layout_t::undefined :

                        // -> Function references require a constructor to handle decayed function pointers.
                        is_function_reference<alias_t>::value ?
                            shadow_layout_t::function_reference :

                        // -> ...
                        is_class<alias_t>::value && (false == is_final<alias_t>::value && false == is_union<alias_t>::value) ?
                            shadow_layout_t::derived :
                            shadow_layout_t::deferred,

                        // ...
                        // -> Refine the underlying `alias_t` type:
                        typename conditional_alias<
                            // -- Allow derivable types be derivable.
                            is_class<alias_t>::value && (false == is_final<alias_t>::value && false == is_union<alias_t>::value),
                            typename remove_cv<typename remove_reference<alias_t>::type>::type,

                        typename conditional_alias<
                            // -- Allow function types be referable instead.
                            is_function<alias_t>::value,
                            typename add_lvalue_reference<alias_t>::type,
                        alias_t >::type >::type
                    > type;
                };

            // [Deference] ... -> Configure the conversion operator of `shadow` (really only to make `enum` types implicitly convertible to their base).
            template <typename alias_t> // For non-enumeration types.
            struct shadow_deference<false, alias_t> : public shadow_layout_alias<alias_t>::type { public:
                template <typename... types>
                constexpr inline shadow_deference(types nodecay... arguments) except(false) : shadow_layout_alias<alias_t>::type super(Utility::forward<types>(arguments)...) {}

                constexpr inline operator typename conditional_alias<is_array<alias_t>::value || is_function<alias_t>::value, alias_t, typename decayof<alias_t>::type>::type&(void) const except(false) { return const_cast<typename conditional_alias<is_array<alias_t>::value || is_function<alias_t>::value, alias_t&, typename decayof<alias_t>::type>::type&>(this -> valueOf()); }
            };

            template <typename alias_t> // -> For enumeration types.
            struct shadow_deference<true, alias_t> : public shadow_layout_alias<alias_t>::type { public:
                template <typename... types>
                constexpr inline shadow_deference(types nodecay... arguments) except(false) : shadow_layout_alias<alias_t>::type super(Utility::forward<types>(arguments)...) {}

                constexpr inline operator typename baseof<alias_t, unsigned int>::type(void) const except(false) { return static_cast<typename baseof<alias_t, unsigned int>::type>(this -> valueOf()); }
                constexpr inline specific operator alias_t&(void) const except(false) { return const_cast<alias_t&>(this -> valueOf()); }
            };
                // ...
                template <typename alias_t>
                struct shadow_deference_alias final { public:
                    typedef shadow_deference<is_enum<alias_t>::value, alias_t> type;
                };

            // [Overlay] ... -> Configure the behavior operator overloads of `shadow`.
            template <typename alias_t> // -> For user-defined types.
            struct shadow_overlay<false, alias_t> : public shadow_deference_alias<alias_t>::type {
                protected:
                    #if __CPP__VERSION__ >= 2011uL
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::address, type>::value, bool>::type = 0x0> constexpr inline static auto address(shadow_overlay const& shadow) except(false) -> typeof(&(instanceof<shadow_overlay<false, type>>().valueOf())) { return &(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::address, type>::value, bool>::type = 0x0> constexpr inline static auto address(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator &())) { return shadow.valueOf().operator &(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::complement, type>::value, bool>::type = 0x0> constexpr inline static auto complement(shadow_overlay const& shadow) except(false) -> typeof(~(instanceof<shadow_overlay<false, type>>().valueOf())) { return ~(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::complement, type>::value, bool>::type = 0x0> constexpr inline static auto complement(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator ~())) { return shadow.valueOf().operator ~(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::dereference, type>::value, bool>::type = 0x0> constexpr inline static auto dereference(shadow_overlay const& shadow) except(false) -> typeof(*(instanceof<shadow_overlay<false, type>>().valueOf())) { return *(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::dereference, type>::value, bool>::type = 0x0> constexpr inline static auto dereference(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator *())) { return shadow.valueOf().operator *(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::negate, type>::value, bool>::type = 0x0> constexpr inline static auto negate(shadow_overlay const& shadow) except(false) -> typeof(!(instanceof<shadow_overlay<false, type>>().valueOf())) { return !(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::negate, type>::value, bool>::type = 0x0> constexpr inline static auto negate(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator !())) { return shadow.valueOf().operator !(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::post_decrement, type>::value, bool>::type = 0x0> constexpr inline static auto post_decrement(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf())--) { return (shadow.valueOf())--; }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::post_decrement, type>::value, bool>::type = 0x0> constexpr inline static auto post_decrement(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator --(int super()))) { return shadow.valueOf().operator --(int super()); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::post_increment, type>::value, bool>::type = 0x0> constexpr inline static auto post_increment(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf())++) { return (shadow.valueOf())++; }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::post_increment, type>::value, bool>::type = 0x0> constexpr inline static auto post_increment(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator ++(int super()))) { return shadow.valueOf().operator ++(int super()); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::pre_decrement, type>::value, bool>::type = 0x0> constexpr inline static auto pre_decrement(shadow_overlay const& shadow) except(false) -> typeof(--(instanceof<shadow_overlay<false, type>>().valueOf())) { return --(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::pre_decrement, type>::value, bool>::type = 0x0> constexpr inline static auto pre_decrement(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator --())) { return shadow.valueOf().operator --(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::pre_increment, type>::value, bool>::type = 0x0> constexpr inline static auto pre_increment(shadow_overlay const& shadow) except(false) -> typeof(++(instanceof<shadow_overlay<false, type>>().valueOf())) { return ++(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::pre_increment, type>::value, bool>::type = 0x0> constexpr inline static auto pre_increment(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator ++())) { return shadow.valueOf().operator ++(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::unary_add, type>::value, bool>::type = 0x0> constexpr inline static auto unary_add(shadow_overlay const& shadow) except(false) -> typeof(+(instanceof<shadow_overlay<false, type>>().valueOf())) { return +(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::unary_add, type>::value, bool>::type = 0x0> constexpr inline static auto unary_add(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator +())) { return shadow.valueOf().operator +(); }
                        template <typename type = alias_t, typename conditional_alias<false == has_operator<shadow_overlay_t::unary_subtract, type>::value, bool>::type = 0x0> constexpr inline static auto unary_subtract(shadow_overlay const& shadow) except(false) -> typeof(-(instanceof<shadow_overlay<false, type>>().valueOf())) { return -(shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<true == has_operator<shadow_overlay_t::unary_subtract, type>::value, bool>::type = 0x0> constexpr inline static auto unary_subtract(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf().operator -())) { return shadow.valueOf().operator -(); }
                    #endif

                public:
                    template <typename... types>
                    constexpr inline shadow_overlay(types nodecay... arguments) except(false) : shadow_deference_alias<alias_t>::type super(Utility::forward<types>(arguments)...) {}

                    constexpr inline typename remove_reference<alias_t>::type& operator ->(void) const except(false) { return this -> valueOf(); }
                    #if __CPP__VERSION__ >= 2011uL
                        template <typename type = alias_t> constexpr friend inline auto operator +(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::unary_add(shadow))) { return shadow_overlay::unary_add(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator -(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::unary_subtract(shadow))) { return shadow_overlay::unary_subtract(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator *(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::dereference(shadow))) { return shadow_overlay::dereference(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator &(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::address(shadow))) { return shadow_overlay::address(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator ~(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::complement(shadow))) { return shadow_overlay::complement(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator !(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::negate(shadow))) { return shadow_overlay::negate(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator ++(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::pre_increment(shadow))) { return shadow_overlay::pre_increment(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator ++(shadow_overlay const& shadow, int const) except(false) -> typeof((shadow_overlay<false, type>::post_increment(shadow))) { return shadow_overlay::post_increment(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator --(shadow_overlay const& shadow) except(false) -> typeof((shadow_overlay<false, type>::pre_decrement(shadow))) { return shadow_overlay::pre_decrement(shadow); }
                        template <typename type = alias_t> constexpr friend inline auto operator --(shadow_overlay const& shadow, int const) except(false) -> typeof((shadow_overlay<false, type>::post_decrement(shadow))) { return shadow_overlay::post_decrement(shadow); }

                        template <typename subalias_t, typename type> constexpr friend inline auto operator +(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() + disambiguate(object)) { return shadow.valueOf() + disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator +(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) + shadow.valueOf()) { return disambiguate(object) + shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator -(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() - disambiguate(object)) { return shadow.valueOf() - disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator -(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) - shadow.valueOf()) { return disambiguate(object) - shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator *(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() * disambiguate(object)) { return shadow.valueOf() * disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator *(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) * shadow.valueOf()) { return disambiguate(object) * shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator /(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() / disambiguate(object)) { return shadow.valueOf() / disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator /(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) / shadow.valueOf()) { return disambiguate(object) / shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator %(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() % disambiguate(object)) { return shadow.valueOf() % disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator %(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) % shadow.valueOf()) { return disambiguate(object) % shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator &(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() & disambiguate(object)) { return shadow.valueOf() & disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator &(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) & shadow.valueOf()) { return disambiguate(object) & shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator |(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() | disambiguate(object)) { return shadow.valueOf() | disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator |(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) | shadow.valueOf()) { return disambiguate(object) | shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ^(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() ^ disambiguate(object)) { return shadow.valueOf() ^ disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ^(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) ^ shadow.valueOf()) { return disambiguate(object) ^ shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <<(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() << disambiguate(object)) { return shadow.valueOf() << disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <<(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) << shadow.valueOf()) { return disambiguate(object) << shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >>(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() >> disambiguate(object)) { return shadow.valueOf() >> disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >>(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) >> shadow.valueOf()) { return disambiguate(object) >> shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ==(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() == disambiguate(object)) { return shadow.valueOf() == disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ==(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) == shadow.valueOf()) { return disambiguate(object) == shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator !=(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() != disambiguate(object)) { return shadow.valueOf() != disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator !=(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) != shadow.valueOf()) { return disambiguate(object) != shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() < disambiguate(object)) { return shadow.valueOf() < disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) < shadow.valueOf()) { return disambiguate(object) < shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() > disambiguate(object)) { return shadow.valueOf() > disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) > shadow.valueOf()) { return disambiguate(object) > shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <=(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() <= disambiguate(object)) { return shadow.valueOf() <= disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <=(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) <= shadow.valueOf()) { return disambiguate(object) <= shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >=(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() >= disambiguate(object)) { return shadow.valueOf() >= disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator >=(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) >= shadow.valueOf()) { return disambiguate(object) >= shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator &&(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() && disambiguate(object)) { return shadow.valueOf() && disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator &&(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) && shadow.valueOf()) { return disambiguate(object) && shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ||(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() || disambiguate(object)) { return shadow.valueOf() || disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ||(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) || shadow.valueOf()) { return disambiguate(object) || shadow.valueOf(); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ,(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof((shadow.valueOf(), disambiguate(object))) { return (shadow.valueOf(), disambiguate(object)); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator ,(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof((disambiguate(object), shadow.valueOf())) { return (disambiguate(object), shadow.valueOf()); }

                        template <typename type = alias_t, typename conditional_alias<false == is_array<type>::value, bool>::type = 0x0> constexpr inline auto operator =(shadow_overlay const& shadow) except(false) -> typeof(this -> valueOf() = shadow.valueOf()) { return (this -> valueOf() = shadow.valueOf()); }
                        template <typename type = alias_t, typename conditional_alias<false == is_array<type>::value, bool>::type = 0x0> constexpr inline auto operator =(shadow_overlay&& shadow) except(false) -> typeof(this -> valueOf() = shadow.valueOf()) { return (this -> valueOf() = shadow.valueOf()); }
                        template <typename type> constexpr inline auto operator +=(type nodecay value) const except(false) -> typeof(this -> valueOf() += value) { return this -> valueOf() += value; }
                        template <typename type> constexpr inline auto operator -=(type nodecay value) const except(false) -> typeof(this -> valueOf() -= value) { return this -> valueOf() -= value; }
                        template <typename type> constexpr inline auto operator *=(type nodecay value) const except(false) -> typeof(this -> valueOf() *= value) { return this -> valueOf() *= value; }
                        template <typename type> constexpr inline auto operator /=(type nodecay value) const except(false) -> typeof(this -> valueOf() /= value) { return this -> valueOf() /= value; }
                        template <typename type> constexpr inline auto operator %=(type nodecay value) const except(false) -> typeof(this -> valueOf() %= value) { return this -> valueOf() %= value; }
                        template <typename type> constexpr inline auto operator &=(type nodecay value) const except(false) -> typeof(this -> valueOf() &= value) { return this -> valueOf() &= value; }
                        template <typename type> constexpr inline auto operator |=(type nodecay value) const except(false) -> typeof(this -> valueOf() |= value) { return this -> valueOf() |= value; }
                        template <typename type> constexpr inline auto operator ^=(type nodecay value) const except(false) -> typeof(this -> valueOf() ^= value) { return this -> valueOf() ^= value; }
                        template <typename type> constexpr inline auto operator <<=(type nodecay value) const except(false) -> typeof(this -> valueOf() <<= value) { return this -> valueOf() <<= value; }
                        template <typename type> constexpr inline auto operator >>=(type nodecay value) const except(false) -> typeof(this -> valueOf() >>= value) { return this -> valueOf() >>= value; }
                        template <typename type> constexpr inline auto operator ->*(type nodecay object) const except(false) -> typeof(this -> valueOf() ->* object) { return this -> valueOf() ->* object; }
                        template <typename... types> constexpr inline auto operator ()(types nodecay... arguments) const except(false) -> typeof(this -> valueOf()(forward<types>(arguments)...)) { return this -> valueOf()(forward<types>(arguments)...); }
                        template <typename type> constexpr inline auto operator [](type nodecay index) const except(false) -> typeof(this -> valueOf()[index]) { return this -> valueOf()[index]; }
                    #endif
                    #if __CPP__VERSION__ >= 2020uL
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <=>(shadow_overlay<false, subalias_t> const& shadow, type nodecay object) except(false) -> typeof(shadow.valueOf() <=> disambiguate(object)) { return shadow.valueOf() <=> disambiguate(object); }
                        template <typename subalias_t, typename type> constexpr friend inline auto operator <=>(type nodecay object, shadow_overlay<false, subalias_t> const& shadow) except(false) -> typeof(disambiguate(object) <=> shadow.valueOf()) { return disambiguate(object) <=> shadow.valueOf(); }
                    #endif
            };

            template <typename alias_t> // -> For base types.
            struct shadow_overlay<true, alias_t> : public shadow_deference_alias<alias_t>::type {
                protected:
                    #if __CPP__VERSION__ >= 2011uL
                        template <typename type = alias_t> constexpr inline auto address(shadow_overlay const& shadow) except(false) -> typeof(&(instanceof<shadow_overlay<false, type>>().valueOf())) { return &(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto complement(shadow_overlay const& shadow) except(false) -> typeof(~(instanceof<shadow_overlay<false, type>>().valueOf())) { return ~(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto dereference(shadow_overlay const& shadow) except(false) -> typeof(*(instanceof<shadow_overlay<false, type>>().valueOf())) { return *(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto negate(shadow_overlay const& shadow) except(false) -> typeof(!(instanceof<shadow_overlay<false, type>>().valueOf())) { return !(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto pre_decrement(shadow_overlay const& shadow) except(false) -> typeof(--(instanceof<shadow_overlay<false, type>>().valueOf())) { return --(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto pre_increment(shadow_overlay const& shadow) except(false) -> typeof(++(instanceof<shadow_overlay<false, type>>().valueOf())) { return ++(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto post_decrement(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf())--) { return (shadow.valueOf())--; }
                        template <typename type = alias_t> constexpr inline auto post_increment(shadow_overlay const& shadow) except(false) -> typeof((instanceof<shadow_overlay<false, type>>().valueOf())++) { return (shadow.valueOf())++; }
                        template <typename type = alias_t> constexpr inline auto unary_add(shadow_overlay const& shadow) except(false) -> typeof(+(instanceof<shadow_overlay<false, type>>().valueOf())) { return +(shadow.valueOf()); }
                        template <typename type = alias_t> constexpr inline auto unary_subtract(shadow_overlay const& shadow) except(false) -> typeof(-(instanceof<shadow_overlay<false, type>>().valueOf())) { return -(shadow.valueOf()); }
                    #endif

                public:
                    template <typename... types>
                    inline shadow_overlay(types nodecay... arguments) except(false) : shadow_deference_alias<alias_t>::type super(Utility::forward<types>(arguments)...) {}
            };
                // ...
                template <typename alias_t>
                struct shadow_overlay_alias final { public:
                    typedef shadow_overlay<is_base<alias_t>::value, alias_t> type;
                };
        }

        template <typename alias_t>
        struct shadow : public shadow_overlay_alias<alias_t>::type {
            public:
                template <typename... types>
                constexpr inline shadow(types nodecay... arguments) except(false) : shadow_overlay_alias<alias_t>::type super(Utility::forward<types>(arguments)...) {}
        };

        // To (Un)Signed
        template <typename type>
        struct to_signed : public alias<
            typename conditional_alias<
                sizeof(type) <= sizeof(signed char), signed char,
            typename conditional_alias<
                sizeof(type) <= sizeof(signed int), signed int,
            typename conditional_alias<
                sizeof(type) <= sizeof(signed long), signed long,
            typename conditional_alias<
                sizeof(type) <= sizeof(signed short), signed short,
                #if __CPP__VERSION__ >= 2011uL
                    signed long long
                #else
                    type
                #endif
            >::type >::type >::type >::type
        > {};
        template <> struct to_signed<unsigned char> : public alias<signed char> {};
        template <> struct to_signed<unsigned int> : public alias<signed int> {};
        template <> struct to_signed<unsigned long> : public alias<signed long> {};
        template <> struct to_signed<unsigned short> : public alias<signed short> {};

        template <typename type>
        struct to_unsigned : public alias<
            typename conditional_alias<
                sizeof(type) <= sizeof(unsigned char), unsigned char,
            typename conditional_alias<
                sizeof(type) <= sizeof(unsigned int), unsigned int,
            typename conditional_alias<
                sizeof(type) <= sizeof(unsigned long), unsigned long,
            typename conditional_alias<
                sizeof(type) <= sizeof(unsigned short), unsigned short,
                #if __CPP__VERSION__ >= 2011uL
                    unsigned long long
                #else
                    type
                #endif
            >::type >::type >::type >::type
        > {};
        template <> struct to_unsigned<signed char> : public alias<unsigned char> {};
        template <> struct to_unsigned<signed int> : public alias<unsigned int> {};
        template <> struct to_unsigned<signed long> : public alias<unsigned long> {};
        template <> struct to_unsigned<signed short> : public alias<unsigned short> {};

        #if __CPP__VERSION__ >= 2011uL
            template <> struct to_signed<unsigned long long> : public alias<signed long long> {};
            template <> struct to_unsigned<signed long long> : public alias<unsigned long long> {};
        #endif
    }

    inline namespace Utility {
        // Decay
        template <typename type>
        constexpr typename decayof<type>::type decay(type nodecay argument) { return static_cast<typename decayof<type>::type>(argument); }

        // PENDING (Lapys)
        // template <typename return_t, typename cast_t> return_t direct_cast(cast_t&&);

        // Forward
        #if __CPP__VERSION__ < 2011uL
            template <typename type> constexpr inline typename remove_const<typename remove_reference<type>::type>::type& forward(typename remove_const<typename remove_reference<type>::type>::type& argument) except(false) { return static_cast<typename remove_const<typename remove_reference<type>::type>::type&>(argument); }
            template <typename type> constexpr inline typename remove_const<typename remove_reference<type>::type>::type const& forward(typename remove_const<typename remove_reference<type>::type>::type const& argument) except(false) { return static_cast<typename remove_const<typename remove_reference<type>::type>::type const&>(argument); }
        #else
            template <typename type> constexpr inline type&& forward(typename remove_reference<type>::type& argument) except(false) { return static_cast<type&&>(argument); }
            template <typename type> constexpr inline type&& forward(typename remove_reference<type>::type&& argument) except(false) { return static_cast<type&&>(argument); }
        #endif
    }
}
