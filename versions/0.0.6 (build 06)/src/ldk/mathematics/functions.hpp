/* Function */
    // Absolute
    inline double abs(const double number) { return number < 0.0 ? -number : number; }
    inline float abs(const float number) { return number < 0.0f ? -number : number; }
    inline int abs(const int number) { return number < 0 ? -number : number; }
    inline long abs(const long number) { return number < 0L ? -number : number; }
    inline long double abs(const long double number) { return number < 0.00 ? -number : number; }
    inline long long abs(const long long number) { return number < 0LL ? -number : number; }
    inline short abs(const short number) { return number < 0 ? -number : number; }
    inline unsigned int abs(const unsigned int number) { return number < 0u ? -number : number; }
    inline unsigned long abs(const unsigned long number) { return number < 0uL ? -number : number; }
    inline unsigned long long abs(const unsigned long long number) { return number < 0uLL ? -number : number; }
    inline unsigned short abs(const unsigned short number) { return number < 0u ? -number : number; }

    // Modulus
    inline double mod(double dividend, double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0.0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, float divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0.0f) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0L) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, long double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0.00) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0LL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, unsigned int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, unsigned long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0uL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, unsigned long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0uLL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }
    inline double mod(double dividend, unsigned short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0 ? -dividend : dividend; } else return Infinity; }

    inline float mod(float dividend, double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0.0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, float divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0.0f) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0L) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, long double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0.00) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0LL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, unsigned int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, unsigned long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0uL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, unsigned long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0uLL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }
    inline float mod(float dividend, unsigned short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.0f) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.0f ? -dividend : dividend; } else return Infinity; }

    inline float mod(int dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline float mod(int dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline int mod(const int dividend, const int divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const long divisor) { return dividend % divisor; }
    inline float mod(int dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline int mod(const int dividend, const long long divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const short divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const unsigned int divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const unsigned long divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline int mod(const int dividend, const unsigned short divisor) { return dividend % divisor; }

    inline double mod(long dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0L) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0L ? -evaluation : evaluation; } else return Infinity; }
    inline double mod(long dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0L) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0L ? -evaluation : evaluation; } else return Infinity; }
    inline long mod(const long dividend, const int divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const long divisor) { return dividend % divisor; }
    inline double mod(long dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0L) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0L ? -evaluation : evaluation; } else return Infinity; }
    inline long mod(const long dividend, const long long divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const short divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const unsigned int divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const unsigned long divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline long mod(const long dividend, const unsigned short divisor) { return dividend % divisor; }

    inline long double mod(long double dividend, double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0.0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, float divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0.0f) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0L) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, long double divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend) || numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0.00) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0LL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, unsigned int divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, unsigned long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0uL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, unsigned long long divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0uLL) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }
    inline long double mod(long double dividend, unsigned short divisor) { if (numberIsInfinite(dividend) || numberIsNaN(dividend)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { if (dividend < 0.00) dividend = -dividend; if (divisor < 0u) divisor = -divisor; while (dividend >= divisor) dividend -= divisor; return dividend < 0.00 ? -dividend : dividend; } else return Infinity; }

    inline long double mod(long long dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0LL) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0LL ? -evaluation : evaluation; } else return Infinity; }
    inline long double mod(long long dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0LL) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0LL ? -evaluation : evaluation; } else return Infinity; }
    inline long long mod(const long long dividend, const int divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const long divisor) { return dividend % divisor; }
    inline long double mod(long long dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0LL) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0LL ? -evaluation : evaluation; } else return Infinity; }
    inline long long mod(const long long dividend, const long long divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const short divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const unsigned int divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const unsigned long divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline long long mod(const long long dividend, const unsigned short divisor) { return dividend % divisor; }

    inline float mod(short dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline float mod(short dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline short mod(const short dividend, const int divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const long divisor) { return dividend % divisor; }
    inline float mod(short dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0 ? -evaluation : evaluation; } else return Infinity; }
    inline short mod(const short dividend, const long long divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const short divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const unsigned int divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const unsigned long divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline short mod(const short dividend, const unsigned short divisor) { return dividend % divisor; }

    inline float mod(unsigned int dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline float mod(unsigned int dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned int mod(const unsigned int dividend, const int divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const long divisor) { return dividend % divisor; }
    inline float mod(unsigned int dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned int mod(const unsigned int dividend, const long long divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const short divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const unsigned int divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const unsigned long divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline unsigned int mod(const unsigned int dividend, const unsigned short divisor) { return dividend % divisor; }

    inline double mod(unsigned long dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uL) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uL ? -evaluation : evaluation; } else return Infinity; }
    inline double mod(unsigned long dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uL) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uL ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned long mod(const unsigned long dividend, const int divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const long divisor) { return dividend % divisor; }
    inline double mod(unsigned long dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uL) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uL ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned long mod(const unsigned long dividend, const long long divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const short divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const unsigned int divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const unsigned long divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline unsigned long mod(const unsigned long dividend, const unsigned short divisor) { return dividend % divisor; }

    inline long double mod(unsigned long long dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uLL) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uLL ? -evaluation : evaluation; } else return Infinity; }
    inline long double mod(unsigned long long dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uLL) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uLL ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned long long mod(const unsigned long long dividend, const int divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const long divisor) { return dividend % divisor; }
    inline long double mod(unsigned long long dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0uLL) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0uLL ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned long long mod(const unsigned long long dividend, const long long divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const short divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const unsigned int divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const unsigned long divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline unsigned long long mod(const unsigned long long dividend, const unsigned short divisor) { return dividend % divisor; }

    inline float mod(unsigned short dividend, double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.0) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline float mod(unsigned short dividend, float divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.0f) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned short mod(const unsigned short dividend, const int divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const long divisor) { return dividend % divisor; }
    inline float mod(unsigned short dividend, long double divisor) { if (numberIsNaN(divisor)) return NaN; else if (numberIsInfinite(divisor)) return dividend; else if (divisor) { float evaluation = (float) dividend; if (dividend < 0u) evaluation = -evaluation; if (divisor < 0.00) divisor = -divisor; while (evaluation >= divisor) evaluation -= divisor; return dividend < 0u ? -evaluation : evaluation; } else return Infinity; }
    inline unsigned short mod(const unsigned short dividend, const long long divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const short divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const unsigned int divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const unsigned long divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const unsigned long long divisor) { return dividend % divisor; }
    inline unsigned short mod(const unsigned short dividend, const unsigned short divisor) { return dividend % divisor; }

    // Logarithm [Base 2]
